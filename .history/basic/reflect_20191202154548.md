## Reflect

与大多数全局对象不同，Reflect不是一个构造函数。你不能将其与一个new运算符一起使用，或者将Reflect对象作为一个函数来调用。Reflect的所有属性和方法都是静态的（就像Math对象）

### apply

Reflect.apply(target, thisArgument, argumentsList)

> 参数

- target

    目标函数

- thisArgument

    target函数调用时绑定的this对象

- argumentList

    target函数调用时传入的实参列表，该参数应该是一个类数组的对象

> 返回值

调用完带着指定参数和 this 值的给定的函数后返回的结果

> example

``` javascript

Reflect.apply(Math.floor, undefined, [1.75]); 
// 1;

Reflect.apply(String.fromCharCode, undefined, [104, 101, 108, 108, 111]);
// "hello"

Reflect.apply(RegExp.prototype.exec, /ab/, ["confabulation"]).index;
// 4

Reflect.apply("".charAt, "ponies", [3]);
// "i"

```

### construct

Reflect.construct(target, argumentsList[, newTarget])

> 参数

- target

    被运行的目标构造函数

- argumentList

    类数组，目标构造函数调用时的参数

- newTarget

    新创建对象的原型对象， 参考 new.target 操作符，默认值为target。

> 返回值

以target（如果newTarget存在，则为newTarget）函数为构造函数，argumentList为其初始化参数的对象实例

> example

```javascript

var d = Reflect.construct(Date, [1776, 6, 4]);
d instanceof Date; // true
d.getFullYear(); // 1776

```

### defineProperty

Reflect.defineProperty(target, propertyKey, attributes)

基本等同于Object.defnieProperty, 唯一不同的是返回了boolean值

### delectProperty

Reflect.deleteProperty(target, propertyKey)

跟delete表达式很像，但是这个是一个函数而不是一个表达水

