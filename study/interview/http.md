# 网络相关

## http相关内容

### http0.9

最初版本的http内容， 只支持get的文本传输

并且必须返回html的文档格式

### http1.0

1. 支持了更多的协议头， post， head
2. 支持了更多的文本格式， content-type
3. 请求格式发生变化， 请求头 + 请求体
4. 响应格式发生变化， 响应头 + 响应体

> 缺点
> 一个tcp连接只能支持一次请求，在一次请求之后会断开连接，可以使用connection: keep-alive，但是不同服务端可能实现会存在不同

### http1.1

1. 支持了长链接，一个请求结束后默认不关闭
2. 支持管道传输，同一个tcp连接可以发送多个请求
3. 添加content-length，申明回应的数据长度
4. 分块传输，（Transfer-Encoding: chunked）

> 缺点
> 在管道传输中，因为会提前先分配每个请求在哪个tcp连接下面， 如果前一个请求没有结束，那么后一个请求就会被前一个阻塞，这叫做队头阻塞

### http2

1. 多路复用
2. 服务端push
3. 二进制协议
4. 头部压缩
5. 数据流

由于在http2里面，请求是以二进制帧的形式发送的，并且保存的方式是以数据流的方式存储，所以每个帧里面都携带上了对应数据流的id，这样就能保证接口请求返回的时候可以不需要等待前一个返回，他们可以同时进行处理， 处理的结果就是以帧的头部内容找到对应的数据流进行储存最后完成请求

数据包发送到一半，在http2里面可以取消这个数据包的发送， 而在http1.1里面只能关闭tcp的链接才行

## 缓存

缓存存在的意义是为了更快的获取资源加快页面的渲染，主要是加快首屏渲染， fcp的时间

在浏览器里面的缓存一共存在两种方式

1. 强缓存
2. 协商缓存

### 强缓存

强缓存顾名思义就是指浏览器直接使用本地缓存而不需要跟服务器进行通信

强缓存一共有两种设置方案

1. expires
2. cache-control: max-age=xxx

expires 是http1.0的产物， 他是一个服务器的具体时间，如果服务器跟客户端的时间相差比较远的话，那可能就会不太精准

cache-control:max-age 是http1.1的， 他设置的是一个时间戳，然后客户端就会记录这个时间戳，如果还在当前时间内，那就可以使用缓存

#### 缓存位置

在浏览器里面缓存的位置有两个， 一个是磁盘，一个是内存

内存的读取会更快一些，一般会存一些图片之类的静态资源，如果当前的tab没有被关闭，重新刷新的话，就会从内存中读取

如果是关闭并重新打开的话，那么就是会从磁盘中读取缓存

### 协商缓存

协商缓存指的是跟服务器进行沟通确认，当前的这个文件是否还可以使用缓存，如果可以的话服务器直接返回304，不可以的话会返回最新的文件，200

设置协商缓存也有两种方式

1. Last-Modified和If-Modified-Since
2. ETag和If-None-Match


last-modified是服务器返回给浏览器的这个文件的最后修改时间，然后浏览器在请求的时候会将这个参数赋值给if-modified-since然后给服务端进行确认

etag也是服务器生成的，他是当前这个文件的一个标识，更加精准的知道文件是否有发生变化，浏览器上报的参数为if-none-match

## websocket

ws是一个前后端及时通信的长链接, 可以理解为他是一个http协议的补充，填补了不能够长时间保留通信的能力

要想ws能通，那还是得依赖于tcp，所以首先还是ws借助http协议发起一个协议升级的请求

upgrade: websocket
connection: Upgrade

如果是wss，那还需要进行tls的检验

之后在tcp通报保持通畅的情况下能够进行全双工通信

## https

https其实就是在http上添加了一层tls协议，为了更加安全的行走在网络当中， 对所有的数据进行了加密

加密方式有两种

- 对称加密
- 非对称加密

由于非对称加密是需要公开公钥，所以任何人都可以在获取公钥的环节进行公钥的替换，这样就对明文进行实际上的获取

如何防止这种情况，目前采用的方案是由CA发放数字证书

1. 客户端向服务端申请数字证书
2. 通过数字证书上跟本机上的CA验证，获取到非对称加密的公钥
3. 使用公钥对明文进行加密
4. 传输加密后的明文给服务端
5. 服务端使用私钥进行解密，返回给应用层